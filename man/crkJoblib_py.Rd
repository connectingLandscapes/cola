% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cola_fun.R
\name{crkJoblib_py}
\alias{crkJoblib_py}
\title{Create cumulative resistance kernels on joblib}
\usage{
crkJoblib_py(
  inshp,
  intif,
  outtif,
  maxdist,
  shape,
  transform = "no",
  volume,
  ncores = as.numeric(Sys.getenv("COLA_NCORES")),
  crs = "None",
  maxram = 6,
  tempFolder = NULL,
  py = Sys.getenv("COLA_PYTHON_PATH"),
  pyscript = system.file(package = "cola", "python/crk_joblib.py"),
  cml = TRUE,
  show.result = TRUE
)
}
\arguments{
\item{inshp}{String. Source points File path to the point layer. Spatial point layer (any ORG driver), CSV (X, Y files), or *.xy file}

\item{intif}{String. Surface resistance File path to the input raster. Requires a GeoTIFF file with square pixels}

\item{maxdist}{Numeric. This is the maximum distance to consider when calculating kernels and should correspond to the maximum dispersal distance of the focal species. Values greater than this will be converted to 0 before summing kernels.}

\item{shape}{String This determines how the probability of dispersal declines with distance from the focal point.
'linear' implements the function `1 - (1/dThreshold) X d` where dThreshold is the specified distance threshold and
 d is the distance from the focal point. 'gaussian' implements the function `exp(-1 x ((d^2)/(2 X (dispScale^2))))` where
 d is the distance from the focal point and dispScale is equal to dThreshold/4. In future versions, users will be able to specify dispScale.}

\item{transform}{String. ’yes’ or ‘no’. If it is set to ‘no’, then no kernel volume transformation is applied and the argument `volume` is ignored. If it is set to ‘yes’, then the value in argument `volume` is used to transform the kernel volume.}

\item{volume}{Numeric. If 1, the default, the resistant kernel value at the origin is 1 and no kernel
volume transformation is applied. If > 1, the parameter value is used to scale distance values by a constant that is
determined by the equation `kVol X 3/(pi X dThreshold^2)` where kVol is the kernel volume parameter, dThreshold is the specified distance threshold, and pi is the mathematical constant pi. The constant is then multiplied by the distances to the focal point resulting in a scaled kernel volume.}

\item{ncores}{Numeric. Number of cores. Number of CPU cores to run the analysis}

\item{crs}{String. Projection string. String. Projection information in the case the input raster 'intif' has no spatial projection. Provide it as EPSG or ESRI string e.g. "ESRI:102028". Default value is ‘None’.}

\item{maxram}{Numeric. RAM to use in GB}

\item{py}{Python executable location. Default is obtained from `Sys.getenv("COLA_PYTHON_PATH")`}

\item{pyscript}{Python script location. Default is obtained from `system.file(package = 'cola', 'python/lcc_joblib.py')`}

\item{cml}{Logical. Print the back-end command line? Default TRUE}

\item{show.result}{Logical. Print the command line result? Default TRUE}

\item{outif}{String. Path output GeoTIFF file name.}
}
\value{
Path with factorial least cost corridors. Each pixel show the number of corridors that connects eac
}
\description{
Run Cumulative resistant kernels algorithm using the parallel computing library joblib. Check more details on the user manual at https://github.com/connectingLandscapes/cola
}
\examples{
library(cola)
outdir <- tempdir()
kernels <- crkJoblib_py(
  inshp = system.file(package = 'cola', 'sampledata/points_sabah_50.shp'),
  intif = system.file(package = 'cola', 'sampledata/sampleSR.tif'),
  outtif = file.path(outdir, 'kernels.tif'),
  maxdist = 100000, shape = 'linear',
  transform = 'no', volume = '1' , maxram = 10)
}
\author{
Ivan Gonzalez <ig299@nau.edu>

Patrick Jantz <Patrick.Jantz@gmail.com>
}
